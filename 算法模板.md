# simpleYang的算法模板


## 二分查找
#### 1、左闭右闭区间写法（最常用）
```js
var search = function(nums, target) {
    let left = 0,right = nums.length-1
    while(left<=right){
        let mid = left + ((right-left)>>1)
        if(nums[mid] === target){
            return mid
        }else if(nums[mid] > target ){
            right = mid-1
        }else{
            left = mid + 1
        }
    }
    return -1
};
```
#### 2、左闭右开区间（可以这么写，但一般直接用上面的更简洁点，注意边界导致的条件修改即可）
```js
var search = function(nums, target) {
    let left = 0,right = nums.length // 1、这里的右边界就是越界的序号了，因为是右开
    while(left<right){ // 2、这里也不能等于了，因为right是无效值，终止条件是 left === right，我们拿不到这个right，等于每次是在[left,right)这个区间进行搜索
        let mid = left + ((right-left)>>1)
        if(nums[mid] === target){
            return mid
        }else if(nums[mid] > target ){
            right = mid // 3、同理right也不需要-1了，下一次区间是[left,right)
        }else{
            left = mid + 1
        }
    }
    return -1
};
```
#### 3、寻找左侧边界的二分搜索
首先思考：返回值代表啥？
nums = [2,3,5,7],target = 1，算法会返回 0，含义是：nums中小于 1 的元素有 0 个
nums = [2,3,5,7], target = 8，算法会返回 4，含义是：nums中小于 8 的元素有 4 个
也代表着我们的模板值应该插入到数组的位置
于是返回条件就不是直接返回-1了，需要判断下返回值与数组长度的关系

1）左闭右开写法（比较常见）
```js
var search = function(nums, target) {
	if (nums.length === 0) return -1; // 直接返回
	
    let left = 0,right = nums.length 
    while(left<right){ 
        let mid = left + ((right-left)>>1)
        if(nums[mid] === target){
            right = mid // 1、这里对比上面的模板，不需要返回了，因为还要继续搜索确定边界
        }else if(nums[mid] > target ){
            right = mid 
        }else{
            left = mid + 1
        }
    }
    // 2、检查出界情况（这一步也可以省略不写，因为正常返回left的话也可以帮我们找到小于target的值有多少个，写这个的话是找最左边那个target的左边有多少个，差不多意思）
    if (left >= nums.length || nums[left] != target) return -1;
    return left // 3、这里返回我们找到的边界序号
};
```
2）左闭右闭写法（统一）
```js
var search = function(nums, target) {
	if (nums.length === 0) return -1; // 直接返回
	
    let left = 0,right = nums.length-1 
    while(left<right){ 
        let mid = left + ((right-left)>>1)
        if(nums[mid] === target){
            right = mid - 1 // 1、只要是闭合，这里就要-1
        }else if(nums[mid] > target ){
            right = mid - 1 // 2、只要是闭合，这里就要-1
        }else{
            left = mid + 1
        }
    }
    if (left >= nums.length || nums[left] != target)  return -1;
    return left
};
```
#### 4、寻找右侧边界的二分搜索
1）左闭右开写法（了解即可）
```js
var search = function(nums, target) {
	if (nums.length === 0) return -1; // 直接返回
	
    let left = 0,right = nums.length // 1.注意
    while(left<right){ 
        let mid = left + ((right-left)>>1)
        if(nums[mid] === target){
            left = mid + 1 // 2、只要是闭合，这里就要+1
        }else if(nums[mid] < target ){
            left = mid + 1 // 3、只要是闭合，这里就要+1
        }else{
            right = mid
        }
    }
    if (left>nums.length || nums[left-1] != target)  return -1; // 5、这里的边界条件如果要返回right-1的话，就要改成right-1>0 || nums[right-1]!==target。建议用left，因为上面left一直+1在缩减边界，更清晰
    return left - 1 // 4、这里要减一，右侧的左闭右开写法专属，因为相等时left会加一，所以结束的时候肯定nums[left]和target不相等。这里的left和right在所有左闭右开都是一样的，因为终止条件就是相等
};
```
2）左闭右闭写法（统一）
```js
var search = function(nums, target) {
	if (nums.length === 0) return -1; // 直接返回
	
    let left = 0,right = nums.length-1 
    while(left<=right){ 
        let mid = left + ((right-left)>>1)
        if(nums[mid] === target){
            left = mid + 1 // 1、只要是闭合，这里就要+1
        }else if(nums[mid] < target ){
            left = mid + 1 // 2、只要是闭合，这里就要+1
        }else{
            right = mid - 1
        }
    }
    if (right<0 || nums[right] != target)  return -1;
    return right
};
```
