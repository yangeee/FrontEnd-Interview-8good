# CSS

## 元素隐藏的方法

* display: none
* visibility: hidden
* opacity: 0
* z-index
* position: absolute 移到可视区域外
* 缩放 transform:scale(0)
* overflow: hidden
* height: 0

# JS

## 数组遍历方式以及速度

速度快慢排序：

1、for === while

2、for of ≈ forEach ≈ for in

3、map （修改原数组，浅拷贝时不占空间）

## this 指向问题

```js
const o1 = {
    text: 'o1',
    fn: function() {
        return this.text;
    }
}
const o2 = {
    text: 'o2',
    fn: o1.fn
}
console.log(o2.fn()); 
```

答案：o2 这里的坑在于习惯性的以为函数被谁调用 this 指向谁，但其实最终调用的时候，是 o2 的执行上下文去堆里面的 fn 函数的地址拿出来的，所以是 o2 ，o2 的 fn 和 o1 的 fn是同一个地址


## valueOf 和 toString

### toString

来自于原型链 Object.prototype.toString()，其他类型的原型链也有继承

功能：把传入的参数转换成字符串

对象：'[object Object]'

数组：相当于数组方法 Array.join(',')   [1,2,3] => '1,2,3'

函数：直接转换 'function(){ console.log('fn') }'

作用：某些场合判断类型更准确

```javascript
toString.call(()=>{})       // [object Function] 
toString.call([])           // [object Array] 
toString.call('')           // [object String] 
toString.call({})           // [object Object] 
toString.call(undefined)    // [object undefined] 
toString.call(null)         // [object null] 
toString.call(22)           // [object Number] 
toString.call(new Date)     // [object Date] 
toString.call(Math)         // [object Math] 
toString.call(window)       // [object Window]
```

#### 什么时候自动调用

使用操作符的时候，如果其中一边为对象，则会先调用 toSting 方法，也就是隐式转换

### valueOf

也来自原型链，返回当前对象的原始值

### 区别

共同点：在输出对象时会自动调用。

不同点：默认返回值不同，且存在优先级关系。

1、强转字符串类型时，将优先调用 toString 方法，强转为数字时优先调用 valueOf

2、使用运算操作符的情况下，valueOf 的优先级高于 toString

## 嵌套的 Promise 执行顺序

![在这里插入图片描述](https://img-blog.csdnimg.cn/4b43a0813f544ea58fab6f50338d960f.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6ams6Iiq5py66ZW_,size_20,color_FFFFFF,t_70,g_se,x_16)

![在这里插入图片描述](https://img-blog.csdnimg.cn/eb062925d291456ab3607c7290dbbb70.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6ams6Iiq5py66ZW_,size_20,color_FFFFFF,t_70,g_se,x_16)

如果 外层第一个 then 中没有返回 Promise，那么在把内层的第一个 then 加入到队列之后，把能执行的都执行了默认返回 undefined 然后把外层 Promise 的 第二个 then 加入到队列

如果返回了 Promise，那么内层 Promise 的 then 全部执行完毕之后才会把外层的 then 加入到队列

## Promise.resolve()

本质：表示 promise 的状态为 fullfilled，可以放 then 方法进入微任务队列

### 1、参数是一个 Promise 实例

Promise.resolve 将不做任何修改、原封不动地返回这个实例。如果有 then 方法会马上推入微任务队列

### 2、参数是一个 thenable 对象

将这个对象转为 Promise 对象，thenable 对象的 then 方法立即推入微任务队列。

### 3、参数不是具有 then方法 的对象，或根本就不是对象

返回一个新的 Promise 对象，状态为 resolved

### 4、不带有任何参数

返回一个 resolved 状态的 Promise 对象，同时 then 方法推入微任务队列。

### 5、Promise.resolve(v)不等于new Promise(r => r(v))

如果是 Promise 里的 resolve(v)，这一句就单独算一个微任务推入队列，而不是立即把 then 推入微任务队列

```javascript
// v是一个实例化的promise，且状态为fulfilled
let v = new Promise(resolve => {
  console.log("begin");
  resolve("then"); 
});
// 最大的陷阱是有些题不写这句话，然而实例 v 中 resolve 之后都会先推入 v 的 .then 然后才
// 推入 new Promise 中的 resolve。就算 v 没有 then 方法也会等待这个不存在的 then 处理完
// 实例 v 状态才会变成 fulfilled
v.then(()=>{console.log('我也会执行')}) 
//--------------------
// 第一种情况：new Promise，结果：begin->1->2->3->then->4
new Promise(resolve => {
    resolve(v);
}).then((v)=>{
    console.log(v)
});

// 第二种情况：直接Promise.resolve(v)，结果：begin->1->then->2->3->4
//原因：Promise.resolve()API如果参数是promise会直接返回这个promise实例，不会做任何处理
// 也就是上面的第一条
Promise.resolve(v).then((v)=>{
    console.log(v)
});
//--------------------
new Promise(resolve => {
  console.log(1);
  resolve();
}).then(() => {
  console.log(2);
}).then(() => {
  console.log(3);
}).then(() => {
  console.log(4);
});
```

## async await的顺序

遇见 await xx() 时，进入 xx 正常执行，碰见微任务就放入微任务队列中，同步任务直接输出。但是微任务如果没做完，下面同步任务也不会执行，所以叫 wait

## try catch

能捕捉到的异常必须是线程执行已经进入 try catch 但 try catch 未执行完的时候抛出来的

同步任务的错误可以捕获

如果 try 里面是异步任务，比如 定时器、Promise，这些异步任务推入对应的任务队列之后，tye catch 的上下文已经不存在了，所以捕获不到错误

除非使用 async await，try 必须等到微任务完成之后才可以往下走，从而结束自己，所以此时可以捕获到，宏任务不用管，因为不属于 await 的处理范畴，加了 await 也是照常推入队列，按宏任务队列顺序输出

## 抽象类

抽象类中可以有非抽象方法，有抽象方法的一定都是抽象类

抽象类不可以被实例化，

抽象类中的抽象方法必须被子类实现

# HTTP 网络

## Cookie

cookie 遵从同站原则，只要是 eTLD+1: 有效顶级域名+二级域名相同即可，如 `taobao.com,baidu.com,sugarat.top`，不需要考虑协议和端口

同源更严格：协议、域名、端口都一致

### Cookie 的属性

#### Expires，Max-Age

Expires：指定一个具体的到期时间，值是 UTC 格式的本地时间，不设置该属性，或者设为 null，Cookie 只在当前会话（session）有效，浏览器窗口关闭，该 Cookie 就会被删除

Max-Age：指定从现在开始 Cookie 存在的秒数

优先级 Max-Age 高

#### Domain，Path

Domain：哪些域名要附带这个 Cookie。默认是当前的二级域名（.com这种才是顶级域名或者叫一级域名），如果服务器在 Set-Cookie 字段指定的域名，不属于当前域名，浏览器会拒绝这个 Cookie，比如阿里的网站设置百度的域名

Path：哪些路径要附带这个 Cookie，设置`/`那么`/docs`也会携带

#### Secure，HttpOnly

Secure：HTTPS 下，才能将这个 Cookie 发送到服务器

HttpOnly：该 Cookie 无法通过 JavaScript 脚本拿到

#### SameSite

比如在掘金点击知乎的链接，设置 strict 不会发送 cookie，不会自动登录。Lax 则会在链接，预加载请求，GET 表单时发送，none 无限制。防止 CSRF 攻击（跨站请求伪造）

HTTP 不支持 None，必须同时加上 Secure 属性

### Cookie 的作用

主要用于以下三个方面：

1. 会话状态管理（如用户登录状态、购物车、游戏分数或其它需要记录的信息）
2. 个性化设置（如用户自定义设置、主题等）
3. 浏览器行为跟踪（如跟踪分析用户行为等）

### Cookie 的缺点

可以从大小、安全、增加请求的大小等方面回答。

### 同站和同源时存储与发送 cookie 的不同

同源时存储和发送都没有问题（毕竟最严格，完全相等）

不同源时分场景：

1、未设置跨域：`XMLHttpRequest.withCredentials=false`搭配服务端的 Access-Control-Allow-Credentials。浏览器不会存储与发送 cookie

2、设置了跨域：`XMLHttpRequest.withCredentials=true`

* 同站：使用 HTTPS 协议的 API，不论 `samesite` 的值，正常存储+发送 cookie。HTTP 协议的 API，只会存储 `samesite` 的值为 `Lax` 和 `Strict` 的 cookie，正常发送 cookie
* 跨站：只能存储和发送  `samesite` 值为 none 的 cookie，并且是 HTTPS 协议（规定），设置了 secure 属性

## Etag 生成原理

不同服务器上生成算法不同，一般而言有几个主要参数可以选择

INode：文件的索引节点(inode)数

MTime： 文件的最后修改日期及时间

Size： 文件的字节数

举例：nginx 中 etag 由响应头的 Last-Modified 与 Content-Length 表示为十六进制组合而成。

```json
ETag: "5cbee66d-264" // 前面是修改时间的十六进制，后面是内容长度的16进制
```

### 如果 http 响应头中 ETag 值改变了，不意味着文件内容一定已经更改

当编辑文件却未更改文件内容时，或者 touch file，MTime 也会改变，此时 etag 改变。当然如果算法没有使用 MTime，就不会改变

### 为什么一般不用 Etag

大厂一般负载均衡调度 HTTP 请求。所以同个客户端的请求很可能分到不同服务器，而根据etag 计算原理，不同服务器资源没变化的情况下，算法可能计算出不同的etag


## Cookie Session Token(jwt) 对比

- HTTP 是无状态的，为了维持前后请求，需要前端存储标记

- cookie 是一种完善的标记方式，通过 HTTP 头或 js 操作，有对应的安全策略，是大多数状态管理方案的基石

- session 是一种状态管理方案，前端通过 cookie 存储 id，后端也要专门存储 id 数据，并且要处理分布式问题，负载均衡时不同机器，需要统一的持久层（Redis）

- token 是另一种状态管理方案，相比于 session 不需要后端存储，数据全部存在前端，解放后端，释放灵活性

- token 的编码技术，通常基于 base64，或增加加密算法防篡改，jwt 是一种成熟的编码方案

- 在复杂系统中，token 可通过 service token（业务的存活时间短暂）、refresh token（刷新的存活时间长） 的分权，同时满足安全性和用户体验

- session 和 token 的对比就是「用不用cookie」和「后端存不存」的对比

- 单点登录要求不同域下的系统「一次登录，全线通用」，通常由独立的 SSO 系统记录登录状态、下发 ticket，各业务系统配合存储和认证 ticket


# Vue

## v-if 和 v-for

2.x 版本中v-for 会优先作用。

3.x 版本中 v-if 总是优先于 v-for 生效


# Npm

## 依赖包版本前的符号的含义

major.minor.patch（有点像 CSGO 比赛）

主版本号.次版本号.修补版本号

### 1、不带任何符号

**必须依赖**这个版本的包

### 2、>、>=、 <、 <=

这几个符号很简单，就是数学意义上的关系，大于、大于等于、小于、小于等于这个版本的安装包都行

### 3、~

向上匹配版本，但不能越级

~1.1.2: 大于等于1.1.2 小于 1.2

~1.1: 大于等于1.1，小于1.2

~1 大于等于1，小于2

### 4、^

小于版本号中最左边的非0数字加1，其余部分，大于等于当前值。

### 5、x

x 的位置表示任意版本

### 6、version1 - version2

大于等于version1，小于等于version2

## 依赖包前的符号

### @

表示这是个范围包，类似作用域，不带符号的是公共包，重名了就不能发

# 设计模式

## 单例模式

```js
let CreateSingleton = (function(){
    let instance;
    return function(name) {
        if (instance) {
            return instance;
        }
        this.name = name;
        return instance = this;
    }
})();
```