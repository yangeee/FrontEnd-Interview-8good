# simpleYang的算法模板


## 二分查找
#### 1、左闭右闭区间写法（最常用）
```js
var search = function(nums, target) {
  let left = 0,right = nums.length-1
  while(left<=right){
    let mid = left + ((right-left)>>1)
    if(nums[mid] === target){
      return mid
    }else if(nums[mid] > target ){
      right = mid-1
    }else{
      left = mid + 1
    }
  }
  return -1
};
```
#### 2、左闭右开区间（可以这么写，但一般直接用上面的更简洁点，注意边界导致的条件修改即可）
```js
var search = function(nums, target) {
  let left = 0,right = nums.length // 1、这里的右边界就是越界的序号了，因为是右开
  while(left<right){ // 2、这里也不能等于了，因为right是无效值，终止条件是 left === right，我们拿不到这个right，等于每次是在[left,right)这个区间进行搜索
    let mid = left + ((right-left)>>1)
    if(nums[mid] === target){
      return mid
    }else if(nums[mid] > target ){
      right = mid // 3、同理right也不需要-1了，下一次区间是[left,right)
    }else{
      left = mid + 1
    }
  }
  return -1
};
```
#### 3、寻找左侧边界的二分搜索
首先思考：返回值代表啥？
nums = [2,3,5,7],target = 1，算法会返回 0，含义是：nums中小于 1 的元素有 0 个
nums = [2,3,5,7], target = 8，算法会返回 4，含义是：nums中小于 8 的元素有 4 个
也代表着我们的模板值应该插入到数组的位置
于是返回条件就不是直接返回-1了，需要判断下返回值与数组长度的关系

1）左闭右开写法（比较常见）
```js
var search = function(nums, target) {
  if (nums.length === 0) return -1; // 直接返回

  let left = 0,right = nums.length
  while(left<right){
    let mid = left + ((right-left)>>1)
    if(nums[mid] === target){
      right = mid // 1、这里对比上面的模板，不需要返回了，因为还要继续搜索确定边界
    }else if(nums[mid] > target ){
      right = mid
    }else{
      left = mid + 1
    }
  }
  // 2、检查出界情况（这一步也可以省略不写，因为正常返回left的话也可以帮我们找到小于target的值有多少个，写这个的话是找最左边那个target的左边有多少个，差不多意思）
  if (left >= nums.length || nums[left] != target) return -1;
  return left // 3、这里返回我们找到的边界序号
};
```
2）左闭右闭写法（统一）
```js
var search = function(nums, target) {
  if (nums.length === 0) return -1; // 直接返回

  let left = 0,right = nums.length-1
  while(left<=right){  // 3、等于
    let mid = left + ((right-left)>>1)
    if(nums[mid] === target){
      right = mid - 1 // 1、只要是闭合，这里就要-1
    }else if(nums[mid] > target ){
      right = mid - 1 // 2、只要是闭合，这里就要-1
    }else{
      left = mid + 1
    }
  }
  if (left >= nums.length || nums[left] != target)  return -1;
  return left
};
```
#### 4、寻找右侧边界的二分搜索
1）左闭右开写法（了解即可）
```js
var search = function(nums, target) {
	if (nums.length === 0) return -1; // 直接返回
	
    let left = 0,right = nums.length // 1.注意
    while(left<right){ 
        let mid = left + ((right-left)>>1)
        if(nums[mid] === target){
            left = mid + 1 // 2、只要是闭合，这里就要+1
        }else if(nums[mid] < target ){
            left = mid + 1 // 3、只要是闭合，这里就要+1
        }else{
            right = mid
        }
    }
    if (left>nums.length || nums[left-1] != target)  return -1; // 5、这里的边界条件如果要返回right-1的话，就要改成right-1>0 || nums[right-1]!==target。建议用left，因为上面left一直+1在缩减边界，更清晰
    return left - 1 // 4、这里要减一，右侧的左闭右开写法专属，因为相等时left会加一，所以结束的时候肯定nums[left]和target不相等。这里的left和right在所有左闭右开都是一样的，因为终止条件就是相等
};
```
2）左闭右闭写法（统一）
```js
var search = function(nums, target) {
	if (nums.length === 0) return -1; // 直接返回
	
    let left = 0,right = nums.length-1 
    while(left<=right){ 
        let mid = left + ((right-left)>>1)
        if(nums[mid] === target){
            left = mid + 1 // 1、只要是闭合，这里就要+1
        }else if(nums[mid] < target ){
            left = mid + 1 // 2、只要是闭合，这里就要+1
        }else{
            right = mid - 1
        }
    }
    if (right<0 || nums[right] != target)  return -1;
    return right
};
```
#### 注意
上述算法找 mid 值都是找的左边，因为向下取整，如果要拿右边的值需要+1，这里遇见过题目的答案是专门找右边的，但是应该也可以用左边做出来，到时候遇见再看
<br>
<hr>

### 滑动窗口
数据是左闭右开格式
```js
var minWindow = function(s, t) {
    let left = 0,right = 0

    while(right < s.length){ // 这样写就成了右开区间，右区间最后终止时right === s.length,s[right]是没有意义的
        let rval = s[right] 
        right ++
         // 进行窗口内数据的一系列更新,比如根据条件对哈希的更新
         
         // 判断左侧窗口是否要收缩
        while(左窗口需要收缩){
            // 如果需要使用到left指针的值，应该在这里，因为下面要+1了
            let lval = s[left]
            left++
       		// 进行窗口内数据的一系列更新，比如根据条件对哈希的更新
        }
        
    }
    // 返回结果
};
```

### 大顶堆、小顶堆（优先队列）
**定义**：大顶堆的每个父节点都大于子节点，根节点是最大的值。小顶堆相反

**如何创建堆**：
完全二叉树可以使用数组存储，堆又是完全二叉树，所以堆也可以用一个数组表示。
给定一个节点的下标 i （i从0开始） ，那么它的父节点位置为(i-1)/2 ，左子节点为 2i + 1 ，右子节点为 2i+2
于是我们可以创建类
```js
class Heap {
	constructor
}
```# simpleYang的算法模板


## 二分查找
#### 1、左闭右闭区间写法（最常用）
```js
var search = function(nums, target) {
    let left = 0,right = nums.length-1
    while(left<=right){
        let mid = left + ((right-left)>>1)
        if(nums[mid] === target){
            return mid
        }else if(nums[mid] > target ){
            right = mid-1
        }else{
            left = mid + 1
        }
    }
    return -1
};
```
#### 2、左闭右开区间（可以这么写，但一般直接用上面的更简洁点，注意边界导致的条件修改即可）
```js
var search = function(nums, target) {
    let left = 0,right = nums.length // 1、这里的右边界就是越界的序号了，因为是右开
    while(left<right){ // 2、这里也不能等于了，因为right是无效值，终止条件是 left === right，我们拿不到这个right，等于每次是在[left,right)这个区间进行搜索
        let mid = left + ((right-left)>>1)
        if(nums[mid] === target){
            return mid
        }else if(nums[mid] > target ){
            right = mid // 3、同理right也不需要-1了，下一次区间是[left,right)
        }else{
            left = mid + 1
        }
    }
    return -1
};
```
#### 3、寻找左侧边界的二分搜索
首先思考：返回值代表啥？
nums = [2,3,5,7],target = 1，算法会返回 0，含义是：nums中小于 1 的元素有 0 个
nums = [2,3,5,7], target = 8，算法会返回 4，含义是：nums中小于 8 的元素有 4 个
也代表着我们的模板值应该插入到数组的位置
于是返回条件就不是直接返回-1了，需要判断下返回值与数组长度的关系

注意点：在查找时，比如 [1,2,3,4,5] 找 -1，那么 left 返回的是 0 ，但是找6的话返回的 left 就是 5，右侧超出是会等于数组长度 arr.length 的，这里要手动减一才行。反之思考寻找右侧边界时，应该左侧最终返回 -1 ，右侧是 arr.length-1  
[找到 K 个最接近的元素](https://leetcode-cn.com/problems/find-k-closest-elements/submissions/)

1）左闭右开写法（比较常见）
```js
var search = function(nums, target) {
	if (nums.length === 0) return -1; // 直接返回
	
    let left = 0,right = nums.length 
    while(left<right){ 
        let mid = left + ((right-left)>>1)
        if(nums[mid] === target){
            right = mid // 1、这里对比上面的模板，不需要返回了，因为还要继续搜索确定边界
        }else if(nums[mid] > target ){
            right = mid 
        }else{
            left = mid + 1
        }
    }
    // 2、检查出界情况（这一步也可以省略不写，因为正常返回left的话也可以帮我们找到小于target的值有多少个，写这个的话是找最左边那个target的左边有多少个，差不多意思）
    if (left >= nums.length || nums[left] != target) return -1;
    return left // 3、这里返回我们找到的边界序号
};
```
2）左闭右闭写法（统一）
```js
var search = function(nums, target) {
	if (nums.length === 0) return -1; // 直接返回
	
    let left = 0,right = nums.length-1 
    while(left<=right){  // 3、等于
        let mid = left + ((right-left)>>1)
        if(nums[mid] === target){
            right = mid - 1 // 1、只要是闭合，这里就要-1
        }else if(nums[mid] > target ){
            right = mid - 1 // 2、只要是闭合，这里就要-1
        }else{
            left = mid + 1
        }
    }
    if (left >= nums.length || nums[left] != target)  return -1;
    return left
};
```
#### 4、寻找右侧边界的二分搜索
1）左闭右开写法（了解即可）
```js
var search = function(nums, target) {
	if (nums.length === 0) return -1; // 直接返回
	
    let left = 0,right = nums.length // 1.注意
    while(left<right){ 
        let mid = left + ((right-left)>>1)
        if(nums[mid] === target){
            left = mid + 1 // 2、只要是闭合，这里就要+1
        }else if(nums[mid] < target ){
            left = mid + 1 // 3、只要是闭合，这里就要+1
        }else{
            right = mid
        }
    }
    if (left>nums.length || nums[left-1] != target)  return -1; // 5、这里的边界条件如果要返回right-1的话，就要改成right-1>0 || nums[right-1]!==target。建议用left，因为上面left一直+1在缩减边界，更清晰
    return left - 1 // 4、这里要减一，右侧的左闭右开写法专属，因为相等时left会加一，所以结束的时候肯定nums[left]和target不相等。这里的left和right在所有左闭右开都是一样的，因为终止条件就是相等
};
```
2）左闭右闭写法（统一）
```js
var search = function(nums, target) {
	if (nums.length === 0) return -1; // 直接返回
	
    let left = 0,right = nums.length-1 
    while(left<=right){ 
        let mid = left + ((right-left)>>1)
        if(nums[mid] === target){
            left = mid + 1 // 1、只要是闭合，这里就要+1
        }else if(nums[mid] < target ){
            left = mid + 1 // 2、只要是闭合，这里就要+1
        }else{
            right = mid - 1
        }
    }
    if (right<0 || nums[right] != target)  return -1;
    return right
};
```
#### 注意
上述算法找 mid 值都是找的左边，因为向下取整，如果要拿右边的值需要+1，这里遇见过题目的答案是专门找右边的，但是应该也可以用左边做出来，到时候遇见再看
<br>
<hr>

### 滑动窗口
数据是左闭右开格式，因为循环终止的条件是right === s.length
```js
var minWindow = function(s, t) {
    let left = 0,right = 0

    while(right < s.length){ // 这样写就成了右开区间，右区间最后终止时right === s.length,s[right]是没有意义的
        let rval = s[right] 
        right ++
         // 进行窗口内数据的一系列更新,比如根据条件对哈希的更新
         
         // 判断左侧窗口是否要收缩
        while(左窗口需要收缩){
            // 如果需要使用到left指针的值，应该在这里，因为下面要+1了
            let lval = s[left]
            left++
       		// 进行窗口内数据的一系列更新，比如根据条件对哈希的更新
        }
        
    }
    // 返回结果
};
```

### 大顶堆、小顶堆（优先队列）
**定义**：大顶堆的每个父节点都大于子节点，根节点是最大的值。小顶堆相反

**如何创建堆**：
完全二叉树可以使用数组存储，堆又是完全二叉树，所以堆也可以用一个数组表示。
给定一个节点的下标 i （i从0开始） ，那么它的父节点位置为(i-1)/2 ，左子节点为 2i + 1 ，右子节点为 2i+2
于是我们可以创建类

注意点：   
1、堆化和出堆操作都要进行down
2、入堆则要进行up
3、主要就是熟悉up、down的操作和原理，其他都是辅助函数写法很多，注意边界即可
4、所有使用了cmp的地方要保证父元素序号在前，这样在定义cmp的时候才符合常识：比如小顶堆前一个大于后一个才交换
```js
class Heap {
	constructor(heap = [],cmp = (a,b)=>a-b>0){ // 1、这里的比较如果是数组就需要改为a[x]、b[x]
    //2、大于0表示需要前一个值大于后一个值时为true，在下面的代码中为true需要交换，所以是小顶堆
      this.heap = heap
      this.cmp = cmp // 定义是大顶堆还是小顶堆
      this.heapify() // 初始堆化
    }
    // 初始的堆化操作，从数组的一半-1开始进行下沉操作即可，是一个优化
    heapify(){
      if(this.size() < 2) return 
      for(let i=Math.floor(this.size()/2)-1;i>=0;i--){
        this.down(i) // 下沉操作
      }
    }
    // 出堆操作：核心就是替换最后一个元素和第一个元素，再把最后一个元素pop掉
    poll(){
      if(this.size()===0){
        return null
      }
      const res = this.heap[0]
      const last = this.heap.pop()
      if(this.size()!==0){ // 空数组就不下沉了
        this.heap[0] = last
        this.down(0)
      }
      return res
    }
    // 上浮：核心是把当前元素一直跟父元素作对比，需要交换就交换,终止条件是0，因为到0了就完成了
    up(index){
      while(index>0){
        const parentIndex = (index-1) >> 1
        if(this.cmp(this.heap[parentIndex],this.heap[index])){
          this.swap(index,parentIndex)
          index = parentIndex
        }else{
          break
        }
      }
    }
    // 下沉：与上浮相反，需要我们拿当前节点一直与左右子节点比较，直到左右子节点都是最后一个子节点或者无需交换
    down(index){
      while(true){
        let leftIndex = index * 2 +1
        let rightIndex = index * 2 + 2
        let findIndex = index
        if(leftIndex < this.size() && this.cmp(this.heap[findIndex],this.heap[leftIndex])){ //1、这里是小于，因为等于时没有意义
          findIndex = leftIndex
        }
        if(rightIndex < this.size() && this.cmp(this.heap[findIndex],this.heap[rightIndex])){
          findIndex = rightIndex
        }
        // 判断父节点是否比某个子节点小，进行替换
        if(index !== findIndex){
          this.swap(index, findIndex)
          index = findIndex //1. 注意交换序号
        }else{
          break
        }
      }
    }
    swap(i1,i2){
      [this.heap[i1],this.heap[i2]] =  [this.heap[i2],this.heap[i1]]
    }
    size(){ return this.heap.length}
    // 查看堆顶
    top(){
      if (this.size() === 0) return null;
      return this.heap[0];
    }
    push(val){
      this.heap.push(val)
      this.up(this.size()-1) // 调整该元素在堆中的位置
    }
}
```